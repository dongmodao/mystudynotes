## 动态分配内存
在 C++ 中，使用如下
``` C++
int n = 10;
int a[n];
```
方式来开辟数组是会报错的，因为 int a[n] 其中的 n 要求是常量，不能是变量，而 int a[10],会在内存中开辟固定大小的的空间往往也不能很好的满足需求，这在使用的时候就非常麻烦。

## 使用 new 来开辟动态内存
使用 new 关键字可以在内存中开辟空间之后返回该空间的首地址。也因为这样，在使用的时候也需要使用指针变量来存储这个开辟的类型空间。
注意：用 new 开辟的内存单元没有名字，指向其首地址的指针是引用其的唯一途径，若指针变量重新赋值，则用 new 开辟的内存单元就在内存中“丢失”了，别的程序也不能占用这段单元，直到重新开机为止。
用 new 分配的地址空间，不能在分配空间时直接进行初始化。

## 使用 delete 来回收动态内存空间
对于使用 new 来开辟空间的指针变量，为了避免造成内存丢失，需要在变量最后一次使用后使用 delete 来回收这些空间。如下：
``` C++
int *p, n;
cin >> n;
p = new int[n]
...
delete p;
```
但是，中间如果 p 被重新赋值，那么就回收不了开辟的空间了，只能等待重新开机自动回收，而且程序会报错。

``` C++
#include<iostream>
using namespace std;
void main(void)
{
	int  *p, n;
	n = 100;
	p = new int[n];
	for (n = 0; n < 100; n++)
		p[n] = n;
	int a[10];
	for (n = 0; n < 10; n++)
		a[n] = 1;
	p = a;
	delete p;
	system("pause");
}
```
上面的程序，对 p 进行了重新赋值，结果是报错了。

